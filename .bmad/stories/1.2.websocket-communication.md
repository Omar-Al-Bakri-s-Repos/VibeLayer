# Story 1.2: WebSocket Communication & Real-Time Foundation

## Status: Draft
**Priority:** 1 (Critical - Core Infrastructure)
**Depends On:** Story 1.1 (Project Infrastructure must be complete)

## Story Statement
**As a** creator,
**I want** instant system responsiveness without page refreshes,
**So that** I can maintain focus on my audience while managing effects seamlessly.

## Acceptance Criteria
1. ✅ Node.js/Fastify WebSocket hub with JWT authentication and mobile network optimization
2. ✅ Connection resilience tested with 10-second network interruptions and automatic recovery
3. ✅ Message protocol designed for mobile constraints with binary optimization where needed
4. ✅ Performance telemetry collection for latency, reliability, and mobile-relevant metrics
5. ✅ Multi-session support with at-least-once delivery guarantees and duplicate detection
6. ✅ WebSocket scaling validation supports target concurrent user loads

## Dev Notes

### Epic Context
This story establishes the real-time communication backbone for VibeLayerAI. All AI suggestions, effect activations, and system status updates flow through this WebSocket infrastructure. This is critical for Stories 1.3-1.8 which all rely on real-time messaging.

### Story Dependencies
- **Depends On:** Story 1.1 (needs auth system and project structure)
- **Blocks:** Stories 1.3, 1.4, 1.5, 1.7 (all need WebSocket for real-time)
- **Parallel Potential:** Can work alongside Story 1.6 (safety controls)

### Technical Architecture

#### WebSocket Protocol (from docs/architecture/5-api-specification.md)
```typescript
interface WSMessage {
  type: 'suggestion' | 'activation' | 'status' | 'panic' | 'heartbeat';
  sessionId: string;
  timestamp: Date;
  payload: any;
}

interface SuggestionMessage extends WSMessage {
  type: 'suggestion';
  payload: {
    effects: RankedEffect[];
    confidence: number;
    intentDetected: IntentType;
    speakerInfo: SpeakerInfo;
  };
}
```

#### Backend Stack (from docs/architecture/3-tech-stack.md)
- **Framework:** Fastify 5.x (high-performance WebSocket server)
- **Runtime:** Node.js 20.x LTS
- **Auth:** BetterAuth JWT tokens for WebSocket authentication
- **Cache:** Redis 7.x for session management
- **Database:** Convex for real-time data

### Implementation Tasks

#### Task 1: Set Up Fastify WebSocket Server
- [ ] Create apps/api-services/src/websocket/server.ts
- [ ] Configure Fastify with @fastify/websocket plugin
- [ ] Set up CORS for control panel origin
- [ ] Implement health check endpoint
- [ ] Configure port and environment variables

#### Task 2: Implement JWT Authentication
- [ ] Create WebSocket authentication middleware
- [ ] Validate JWT tokens from BetterAuth on connection
- [ ] Implement token refresh mechanism
- [ ] Handle authentication failures gracefully
- [ ] Add rate limiting per creator ID

#### Task 3: Design Message Protocol
- [ ] Define message types in packages/protocol/
- [ ] Create TypeScript interfaces for all message types
- [ ] Implement message validation with Zod schemas
- [ ] Add binary encoding for large payloads
- [ ] Create message routing system

#### Task 4: Build Connection Resilience
- [ ] Implement automatic reconnection logic
- [ ] Add exponential backoff for retries
- [ ] Create connection state management
- [ ] Handle 10-second network interruptions
- [ ] Implement heartbeat/ping-pong mechanism

#### Task 5: Add Multi-Session Support
- [ ] Create session manager with Redis
- [ ] Implement session ID generation
- [ ] Handle multiple connections per creator
- [ ] Add message queuing for offline clients
- [ ] Implement at-least-once delivery guarantees

#### Task 6: Implement Telemetry Collection
- [ ] Add latency measurement for messages
- [ ] Track connection reliability metrics
- [ ] Monitor message throughput
- [ ] Log mobile-specific metrics (reconnects, packet loss)
- [ ] Integrate with Sentry for error tracking

#### Task 7: Create Client SDK
- [ ] Build TypeScript client in packages/protocol/client
- [ ] Implement auto-reconnection in client
- [ ] Add message queue for offline sending
- [ ] Create React hooks for control panel
- [ ] Add connection status indicators

#### Task 8: Performance Optimization
- [ ] Implement message batching
- [ ] Add compression for text payloads
- [ ] Optimize for mobile networks (reduce overhead)
- [ ] Configure WebSocket frame size
- [ ] Add connection pooling

### File Locations
- WebSocket server: `/apps/api-services/src/websocket/`
- Protocol definitions: `/packages/protocol/src/`
- Client SDK: `/packages/protocol/client/`
- Message handlers: `/apps/api-services/src/websocket/handlers/`
- Session management: `/apps/api-services/src/services/session/`

### Testing Requirements
- Unit tests for message validation and routing
- Integration tests for authentication flow
- Load tests for 1000+ concurrent connections
- Network resilience tests with simulated interruptions
- Latency benchmarks (<100ms p99)
- Mobile network simulation tests

### Technical Constraints
- Must maintain <100ms message latency (p99)
- Support 10,000 concurrent connections per server
- Message size limit: 256KB for standard, 10MB for binary
- Automatic reconnection within 5 seconds
- JWT token validation on every connection

## Definition of Done
- [ ] WebSocket server running on port 3001
- [ ] Authentication working with BetterAuth JWTs
- [ ] Message protocol fully defined and documented
- [ ] Client can connect and exchange messages
- [ ] Connection resilience tested and verified
- [ ] Multi-session support implemented
- [ ] Telemetry dashboard showing metrics
- [ ] Load test passing with 1000 connections
- [ ] Client SDK published to packages
- [ ] API documentation updated